#+TITLE: Emacs customizations to maximize John's Emacs
#+TITLE:     jmax.org
#+AUTHOR:    John Kitchin
#+EMAIL:     jkitchin@cmu.edu
#+DATE:      2012-12-12 Wed
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

* tasks
empty

* personal setup                                                   :personal:
Obviously this will have to be customized.

#+begin_src emacs-lisp
;; I need some lisp voodoo here to set paths according to the machine I am on.
(when (or (string= system-name "jkitchin-780.cheme.cmu.edu")
	  (string= system-name "gilgamesh.cheme.cmu.edu"))
  (setq org-agenda-files '("~/Dropbox/org-mode"))
  (defvar my-aspell "aspell"))

(when (or (string= system-name "JKITCHIN-PC")
	  (string= system-name "KITCHIN-TABLET"))
  (setq org-agenda-files '("c:/Users/jkitchin/Dropbox/org-mode"))
  (defvar my-aspell "C:/Program Files/Aspell/bin/aspell.exe"))

(when (or (string= system-name "HOME-OFFICE")
          (string= system-name "JKITCHIN-2012"))
  (setq org-agenda-files '("c:/Users/jkitchin/Dropbox/org-mode"))
  (defvar my-aspell "C:/Program Files (x86)/Aspell/bin/aspell.exe"))

;;Tell the program who you are
(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")

; adapted from http://ergoemacs.org/emacs/emacs_hotkey_open_file_fast.html
(defun j-open-file-fast (openCode)
  "Prompt to open a file from a pre-defined set."
  (interactive "sOpen file: [m]master.org [b]blog [j]jmax.org:")
  (let (file )
    (setq file
          (cond
           ((string= openCode "m") "~/Dropbox/org-mode/master.org" )
           ((string= openCode "j") "~/Dropbox/.emacs.d/jmax.org" )
           ((string= openCode "b") "~/Dropbox/jkitchin.github.com/source/_org")           
           (t (error "You typed %s, it doesn't associate with a file." openCode ))
           )
          )
    (find-file file ) ) )

(global-set-key [f9] 'j-open-file-fast)
#+end_src

#+RESULTS:

* Basic customizations
#+BEGIN_SRC emacs-lisp
;(setq frame-title-format "jmax - awesome editing")

;; set frame title to something useful
(setq frame-title-format
  '((buffer-file-name "%f"
    (dired-directory dired-directory "%b"))))


(tool-bar-mode 0) ; remove the icons
(menu-bar-mode 1) ; keep the menus
(global-visual-line-mode 1) ;; how long lines are handled.
                            ;; This appears to wrap long lines

(global-font-lock-mode t)   ;; turn on font-lock mode everywhere

(show-paren-mode 1)         ;; highlight parentheses
(setq show-paren-style 'mixed) ;; alternative is 'expression, 'parenthesis or 'mixed

(line-number-mode 1)  ;; turn linumbers on in mode-line
;(global-linum-mode t) ;; put line numbers on left side of the screen

(setq backup-inhibited t)  ;; disable backup file creation

(setq inhibit-startup-screen t) ;; stop showing startup screen

(fset 'yes-or-no-p 'y-or-n-p) ; answer with y/n instead of yes/no

(global-set-key (kbd "C-x C-b") 'ibuffer)
(require 'ido)
(ido-mode t)
(setq ido-enable-flex-matching t) ;; enable fuzzy matching

;; Disable all version control. makes startup and opening files much faster
(setq vc-handled-backends nil)
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | (save-buffer) | (load-file (concat starter-kit-dir /init.el)) |

** abbrev mode
#+begin_src emacs-lisp
(abbrev-mode 1) ; turn abbrev mode on
(setq-default abbrev-mode t)
(setq abbrev-file-name (concat starter-kit-dir "abbrev_defs"))
(if (not (file-exists-p abbrev-file-name))
(progn (find-file-noselect abbrev-file-name) (write-file abbrev-file-name))
)
(read-abbrev-file (concat starter-kit-dir "abbrev_defs"))
(setq save-abbrevs t)
#+end_src

#+RESULTS:

** packages to always load
#+begin_src emacs-lisp
  (require 'cl)           ;; common-lisp functions

  (require 'saveplace)     ;; When you visit a file, point goes to the
                           ;; last place where it was when you
                           ;; previously visited the same file.

  (require 'ffap)          ;; find-file-at-point

  (require 'uniquify)      ;; overrides Emacs' default mechanism for
                           ;; making buffer names unique (using suffixes
                           ;; like <2>, <3> etc.) with a more sensible
                           ;; behaviour which use parts of the file
                           ;; names to make the buffer names
                           ;; distinguishable.

  (require 'ansi-color)    ;; translates ANSI SGR (Select Graphic
                           ;; Rendition) escape sequences like "Esc [ 30
                           ;; m" into EmacsOverlays, TextProperties, or
                           ;; XEmacsExtents with face colours, bold,
                           ;; etc.

  (require 'recentf)       ;; Toggles "Open recent" menu
  (require 'eieio)
#+end_src

* Setup package manager
#+begin_src emacs-lisp
(setq package-archives
      '(("gnu"         . "http://elpa.gnu.org/packages/")
	("original"    . "http://tromey.com/elpa/")
	("org"         . "http://orgmode.org/elpa/")
	("melpa" . "http://melpa.milkbox.net/packages/")
	("marmalade"   . "http://marmalade-repo.org/packages/")))
(package-initialize)

(setq package-user-dir (concat starter-kit-dir "/elpa"))

;;   (defvar starter-kit-packages
;;     (list 'yasnippet-bundle
;;           'magit)
;;     "Libraries that should be installed by default.")

;;   (unless package-archive-contents
;;     (package-refresh-contents))

;;   (dolist (package starter-kit-packages)
;;     (unless (package-installed-p package)
;;       (package-install package)))
#+end_src

#+RESULTS:

* color theme
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path (concat starter-kit-dir "/themes"))
(load-theme 'my t)
#+END_SRC

#+RESULTS:
: t

* auto-complete
see: http://cx4a.org/software/auto-complete/manual.html
#+begin_src emacs-lisp
(add-to-list 'load-path (concat starter-kit-dir "/auto-complete-1.3.1"))
(require 'auto-complete-config)
(add-to-list 'ac-dictionary-directories (concat starter-kit-dir "/auto-complete-1.3.1/ac-dict"))
(ac-config-default)
#+end_src

* spell-checking
#+begin_src emacs-lisp
(require 'ispell)
(setq flyspell-issue-welcome-flag nil)
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "C-<f8>") 'flyspell-mode)
(flyspell-mode t)

(setq-default ispell-program-name my-aspell)
(setq ispell-personal-dictionary (concat starter-kit-dir "/.ispell"))
(setq text-mode-hook '(lambda()
			(flyspell-mode t)       ; spellchek (sic) on the fly
			))
;;(setq ispell-personal-dictionary (concat starter-kit-dir "Dropbox/.emacs.d/.ispell"))

;; stop annoying boxes from popping up when no makefile foundx
(setq flymake-gui-warnings-enabled nil)
#+end_src
* org-mode
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'org-special-blocks)
(require 'org-inlinetask)

(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
(global-set-key [f12] 'org-mode)

(global-set-key "\C-e" 'end-of-line); overwrites org-mode \C-e definition

(global-set-key "\C-cL" 'org-insert-link-global)
(global-set-key "\C-co" 'org-open-at-point-global)

; I like to press enter to follow a link. mouse clicks also work.
(setq org-return-follows-link t)

(load "jorg-bib.el")
#+END_SRC

** basic setup
#+BEGIN_SRC emacs-lisp
; use syntax highlighting in org-file code blocks
(setq org-src-fontify-natively t)

; do not evaluate code on export by default
(setq org-export-babel-evaluate nil)

; enable prompt-free code running
(setq org-confirm-babel-evaluate nil)
(setq org-confirm-elisp-link-function nil)

; register languages in org-mode
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (org . t)))

; no extra indentation
(setq org-src-preserve-indentation t)
(setq org-startup-with-inline-images "inlineimages")
#+END_SRC
** agenda setup
#+BEGIN_SRC emacs-lisp
; I don't want to see things that are done. turn that off here.
; http://orgmode.org/manual/Global-TODO-list.html#Global-TODO-list
(setq org-agenda-skip-scheduled-if-done t)
(setq org-agenda-skip-deadline-if-done t)
(setq org-agenda-skip-timestamp-if-done t)
(setq org-agenda-todo-ignore-scheduled t)
(setq org-agenda-todo-ignore-deadlines t)
(setq org-agenda-todo-ignore-timestamp t)
(setq org-agenda-todo-ignore-with-date t)
(setq org-agenda-start-on-weekday nil) ;; start on current day

(setq org-upcoming-deadline '(:foreground "blue" :weight bold))

(setq org-deadline-warning-days 0)

(setq org-agenda-custom-commands
      '(("w" "Weekly Review"
         (
          ;; deadlines
          (tags-todo "+DEADLINE<=\"<today>\""
                     ((org-agenda-overriding-header "Late Deadlines")
                      ;(org-agenda-tags-todo-honor-ignore-options t)
                      ;(org-agenda-todo-ignore-scheduled t)
                      ;(org-agenda-todo-ignore-deadlines t)
		      ))

          ;; scheduled  past due
          (tags-todo "+SCHEDULED<=\"<today>\""
                     ((org-agenda-overriding-header "Late Scheduled")
                      ;(org-agenda-tags-todo-honor-ignore-options t)
                      ;(org-agenda-todo-ignore-scheduled t)
                      ;(org-agenda-todo-ignore-deadlines t)
		      ))

	  ;; now the agenda
	  (agenda ""
		  ((org-agenda-overriding-header "weekly agenda")
		   (org-agenda-ndays 7)
		   (org-agenda-tags-todo-honor-ignore-options t)
		   (org-agenda-todo-ignore-scheduled nil)
		   (org-agenda-todo-ignore-deadlines nil)
		   (org-deadline-warning-days 0)
		   ))

	  ;; and last a global todo list
          (todo "TODO"))) ;; review waiting items ...other commands
			     ;; here
        ))

(setq org-log-done 'time)
#+END_SRC

#+RESULTS:

** IMAGE handling
#+BEGIN_SRC emacs-lisp
(setq org-startup-with-inline-images "inlineimages")

;; enable image mode first
(iimage-mode)
;; add the org file link format to the iimage mode regex
(add-to-list 'iimage-mode-image-regex-alist
  (cons (concat "\\[\\[file:\\(~?" iimage-mode-image-filename-regex "\\)\\]")  1))
;;  add a hook so we can display images on load
(add-hook 'org-mode-hook '(lambda () (org-turn-on-iimage-in-org)))
;; function to setup images for display on load
(defun org-turn-on-iimage-in-org ()
  "display images in your org file"
  (interactive)
  (turn-on-iimage-mode)
  (set-face-underline-p 'org-link nil))
;; function to toggle images in a org buffer
(defun org-toggle-iimage-in-org ()
  "display images in your org file"
  (interactive)
  (if (face-underline-p 'org-link)
      (set-face-underline-p 'org-link nil)
      (set-face-underline-p 'org-link t))
  (call-interactively 'iimage-mode))
#+END_SRC
** default output for code blocks
#+BEGIN_SRC emacs-lisp
; set default :results to output
(setq org-babel-default-header-args
      (cons '(:results . "replace output")
	    (assq-delete-all :results org-babel-default-header-args)))

; set default exports to both code and results
(setq org-babel-default-header-args
      (cons '(:exports . "both")
	    (assq-delete-all :exports org-babel-default-header-args)))
#+END_SRC

** publishing setup
#+BEGIN_SRC emacs-lisp
(setq org-export-latex-default-packages-alist
      (quote
       (("AUTO" "inputenc" t)
	("" "fixltx2e" nil)
	("" "url")
	("" "graphicx" t)
	("" "minted" t)
	("" "color" t)
	("" "longtable" nil)
	("" "float" nil)
	("" "wrapfig" nil)
	("" "soul" t)
	("" "textcomp" t)
	("" "amsmath" t)
	("" "marvosym" t)
	("" "wasysym" t)
	("" "latexsym" t)
	("" "amssymb" t)
	("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)
	("" "attachfile" t)
	"\\tolerance=1000")))

; this is for code syntax highlighting
(setq org-export-latex-listings 'minted)

(setq org-export-latex-minted-options
           '(("frame" "lines")
             ("fontsize" "\\scriptsize")
             ("linenos" "")))

; for minted you must run latex with -shell-escape because it calls pygmentize as an external program
(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

;(setq org-latex-to-pdf-process '("texi2dvi --pdf --clean --verbose --batch")) 
#+END_SRC
** org-mode links
*** pydoc
#+BEGIN_SRC emacs-lisp
; here is a way to get pydoc in a link: [[pydoc:numpy]]
(setq org-link-abbrev-alist
      '(("pydoc" . "shell:pydoc %s")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; these allow me to write mod:numpy or func:numpy.dot to get
;; clickable links to documentation
(org-add-link-type
 "mod"
 (lambda (arg)
   (shell-command (format "pydoc %s" arg) nil))
 (lambda (path desc format)
   (cond
    ((eq format 'latex)
     (format "\\texttt{%s}" path)))))

(org-add-link-type
 "func"
 (lambda (arg)
   (shell-command (format "pydoc %s" arg) nil))
 (lambda (path desc format)
   (cond
    ((eq format 'latex)
     (format "\\texttt{%s}" path)))))
#+END_SRC

*** links to microsoft files
#+BEGIN_SRC emacs-lisp
;;; support for links to microsoft docx,pptx,xlsx files
;;; standard org-mode opens these as zip-files
;;  http://orgmode.org/manual/Adding-hyperlink-types.html
(org-add-link-type "msx" 'org-msx-open)

(defun org-msx-open (path)
       "Visit the msx file on PATH.

uses the dos command:
start  empty title path
"
       (shell-command
	(concat "start \"title\" " (shell-quote-argument path)) t))
#+END_SRC

*** asynchronous shell commands
#+BEGIN_SRC emacs-lisp
(org-add-link-type "ashell" 'org-ashell-open)
(defun org-ashell-open (cmd)
"open an ashell:cmd link
[[ashell:xterm -e \"cd 0; ls && /bin/bash\"]]

I use this to run commands asynchronously in the shell. org-mode runs shell links in a blocking mode, which is annoying when you open an xterm."
(start-process-shell-command "ashell" "*scratch*" cmd))
#+END_SRC

*** colored text
#+BEGIN_SRC emacs-lisp
;; -*- emacs-lisp -*-   [[color:red][in red]]
(org-add-link-type
 "color"
 (lambda (path)
   (message (concat "color "
		    (progn (add-text-properties
			    0 (length path)
			    (list 'face `((t (:foreground ,path))))
			    path) path))))
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span style=\"color:%s;\">%s</span>" path desc))
    ((eq format 'latex)
     (format "{\\color{%s}%s}" path desc)))))
#+END_SRC

*** VASP incar keyword link
#+BEGIN_SRC emacs-lisp
;; -*- emacs-lisp -*-   [[incar:keyword]]
;; this makes nice links in org-mode to the online documentation and
;; renders useful links in output
;;
;; (org-add-link-type TYPE &optional FOLLOW EXPORT)
;; FOLLOW is the function that takes the path and does what is
;; necessary to "follow" the link.
;; EXPORT takes three args
;;  path the path of the link, the text after the prefix (like "http:")
;;
;;  desc the description of the link, if any, or a
;;  description added by org-export-normalize-links if there is none
;;
;;  format the export format, a symbol like `html' or `latex' or
;;  `ascii'..
(org-add-link-type "incar"
;; FOLLOW code
  (lambda (keyword)
    (shell-command (format "firefox http://cms.mpi.univie.ac.at/wiki/index.php/%s" keyword) nil))
;; FORMAT code
  (lambda (keyword description format)
   (cond
    ((eq format 'html)
     (format "<a href=http://cms.mpi.univie.ac.at/wiki/index.php/%s>%s</a>" keyword keyword))
    ((eq format 'latex)
     (format "\\href{http://cms.mpi.univie.ac.at/wiki/index.php/%s}{%s}"  keyword keyword)
))))
#+END_SRC

*** experimental image link
This was to have a way to put a single file name into an org-file, but get the right figure type for different outputs, e.g. png for html, and pdf for pdflatex
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "image"
 (lambda (keyword)
   ()) ; do nothing. maybe figure out how to open a png or pdf
 (lambda (keyword link format)
   (cond
    ((eq format 'latex)
     (format "\\includegraphics{%s.pdf}" keyword)))))
#+END_SRC

*** citeulike link						   :noexport:
This adds a way to link to articles in citeulike. The syntax is citeu:11819912 or [[citeu:11819912, 11819910]]. The link exports as urls in brackets in html and as superscripted urls in latex. In org-mode if you click on the key, it will launch a browser opening to that article.

Known limitations: if they key is not recognized as a word by emacs, the clicking will not work as expected. eg. if your key is something like j:345, this is not recognized as a word by emacs.

#+BEGIN_SRC emacs-lisp
(require 'thingatpt)

(defvar citeu-user "jkitchin"
  "The username for your citeulike account")

(defvar citeu-url (format
                   "http://www.citeulike.org/user/%s/article/"
                   citeu-user)
  "the url that points to an article in citeulike. you add a key to the end to get a specific article.")

(defun citeu-strip-key (key)
  "strip leading and trailing whitespace from the key"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" key) ))

(defun citeu-split-keys (key-string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'citeu-strip-key (split-string key-string ",")))

(defun citeu-visit-key-at-point (arg)
  "find key at point and open a browser to the corresponding citeulike page"
  (let ((key (word-at-point)))
  (browse-url (concat citeu-url key))))

(defun citeu-make-html-link (stripped-key)
  "construct one href link from a stripped-key."
  (let ((href (concat citeu-url stripped-key)))
    (concat "<a href=\"" href "\">" stripped-key "</a>")))

(defun citeu-make-html-links (stripped-keys)
  "combine all links in brackets and output the html code"
  (interactive)
  (concat "[" (mapconcat 'citeu-make-html-link stripped-keys ", ") "]"))

(defun citeu-make-latex-link (stripped-key)
  "make a latex link from a stripped key"
  (let ((href (concat citeu-url stripped-key)))
     (concat "{\\href{" href"}{" stripped-key "}")))

(defun citeu-make-latex-links (stripped-keys)
  "construct links as superscripted bracketed links in latex"
  (interactive)
  (concat "$^{[" (mapconcat 'citeu-make-latex-link stripped-keys ", ") "]$"))

(org-add-link-type "citeu"
  ; visit the key the cursor is on when clicked or Entered
  'citeu-visit-key-at-point
  ; formatting
  (lambda (keyword desc format)
    (cond
     ((eq format 'html)
      (citeu-make-html-links (citeu-split-keys keyword)))
     ((eq format 'latex)
      (citeu-make-latex-links (citeu-split-keys keyword)))
      )))
#+END_SRC

*** cite links							   :noexport:

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;
;; implemenation of cite:  to make bibtex citations that are also clickable.
;; similar to the citeu link, you can click on one key and open that bibtex entry

(defun cite-find-bibliography ()
  "find the bibliography file(s) in the buffer

search for [[bibliography:()]]
and extract out what is in the () with a regexp

returns a list of stripped file names"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "bibliography:\\([^\]\|\n]+\\)" nil t)
    (setq cite-bibliography-files
          (mapcar 'cite-strip-key (split-string (match-string 1) ",")))))

(defun cite-goto-bibentry (bibfile key)
  "open bibfile in another window at the key"
  (interactive)
  (find-file-other-window bibfile)
  (goto-char (point-min)) ; always start search from beginning.
  (re-search-forward key nil t 1))

(defun cite-strip-key (key)
  "strip leading and trailing whitespace from the key"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" key)))

(defun cite-split-keys (key-string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'citeu-strip-key (split-string key-string ",")))

(defun cite-key-in-file-p (key filename)
  "determine if the key is in the file"
  (with-temp-buffer
    (insert-file-contents filename)
    (goto-char (point-min))
    (search-forward key nil t 1)))

(defun cite-onclick (link-string)
   ;; This code opens the bibtex file containing the clicked on
   ;; key. First we find the boundaries of the link you clicked on,
   ;; then identify the key you clicked on.
   (save-excursion
     (beginning-of-line) ; search forward from beginning of the line
     (search-forward link-string nil t 1)
     (setq link-string-beginning (match-beginning 0))
     (setq link-string-end (match-end 0)))
   ;; now we want to search forward to next comma from point
   (save-excursion
     (if (search-forward "," link-string-end 1 1)
         (setq key-end (- (match-end 0) 1)) ; we found a match
       (setq key-end (point)))) ; no comma found so take the point
   ;; and backward to previous comma from point
   (save-excursion
     (if (search-backward "," link-string-beginning 1 1)
         (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
       (setq key-beginning (point)))) ; no match found
                                        ; save the key we clicked on.
   (setq bibtex-key (cite-strip-key (buffer-substring key-beginning key-end)))
   (message "(%s %s) p=%s %s %s: %s"
            link-string-beginning
            link-string-end
            (point)
            key-beginning
            key-end
            bibtex-key )
   ;; now we get the bibliography files
   (setq cite-bibliography-files (cite-find-bibliography))
   ;(message "%S" cite-bibliography-files))
   ;; now find the first bib file containing the key
   (setq bib-file (loop for file in cite-bibliography-files do
         (if (cite-key-in-file-p bibtex-key file) (return file))))
   ;; and finally, open the file at the key
   (cite-goto-bibentry bib-file  bibtex-key))

(defun cite-make-latex-links (stripped-keys)
  "construct links as superscripted bracketed links in latex"
  (interactive)
  (concat "\\cite{" (mapconcat (lambda (key) key) stripped-keys ",") "}"))

(org-add-link-type
 "cite"
 'cite-onclick
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite{" 
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))

(org-add-link-type
 "citealp"
 'cite-onclick
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (concat "\\citealp{" 
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))

(setq reftex-cite-format "[[cite:%l]]")
#+END_SRC

Here we add links for the bibliography and bibliography style
#+begin_src emacs-lisp
;; link to hold a bibliography bibtex file. Mostly so I can click on the link and open the file.
;; TODO replace click code to open file at point.
(org-add-link-type "bibliography"
(lambda (link-string)
    (save-excursion
     (beginning-of-line) ; search forward from beginning of the line
     (search-forward link-string nil t 1)
     (setq link-string-beginning (match-beginning 0))
     (setq link-string-end (match-end 0)))
   ;; now we want to search forward to next comma from point
   (save-excursion
     (if (search-forward "," link-string-end 1 1)
         (setq key-end (- (match-end 0) 1)) ; we found a match
       (setq key-end (point)))) ; no comma found so take the point
   ;; and backward to previous comma from point
   (save-excursion
     (if (search-backward "," link-string-beginning 1 1)
         (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
       (setq key-beginning (point)))) ; no match found
                                        ; save the key we clicked on.
   (setq bibfile (cite-strip-key (buffer-substring key-beginning key-end)))
(find-file bibfile)) ; open file on click
;; formatting code
(lambda (keyword desc format)
  (cond
   ((eq format 'html) (format ""))
   ((eq format 'latex)
    ; write out the latex bibliography command
    (format "\\bibliography{%s}" (replace-regexp-in-string  ".bib" "" keyword))))))

(org-add-link-type "bibliographystyle"
(lambda (arg) (message "Nothing implemented for clicking here.")) ; open file on click
(lambda (keyword desc format)
  (cond
   ((eq format 'latex)
    ; write out the latex bibliography command
    (format "\\bibliographystyle{%s}" keyword)))))
#+end_src

*** ref and label links						   :noexport:
The idea here is to create links for label and ref. The reason for these additions is to provide clickable links to the references and labels, along with the org-mode navigation to quickly go back to where you were. These links get formatted to \ref and \label for latex. They are not formatted for HTML export yet.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "ref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (let ((n (count-matches (format "\\label{%s}" label) (point-min) (point-max) t)))
     (if (< n 1) (error (format "no matching label found for \\label{%s}!" label)))
     (if (> n 1) (error (format "%d matches found for %s!" n label)))
   (org-mark-ring-push)
   (goto-char (point-min))
   (re-search-forward (format "\\label{%s}" label))
   (message "go back with `C-c &`")))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\ref{%s}" keyword)))))

(org-add-link-type
 "label"
 (lambda (label)
   "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
   (count-matches (format "label:%s\\b" label) (point-min) (point-max) t))
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\label{%s}" keyword)))))
#+END_SRC

#+RESULTS:
** reftex setup							   :noexport:
This allows you insert citations from reftex. I am not sure I like this a lot, as I prefer the citations to go in as links. I think this can be done via ebib, or I will one day write my own insert citation function that puts in the links I want like these [[cite links]].

#+BEGIN_SRC emacs-lisp
(defun org-mode-reftex-setup ()
  (load-library "reftex")
  (and (buffer-file-name)
       (file-exists-p (buffer-file-name))
       (reftex-parse-all))
  (setq reftex-cite-format "cite:%l") ; use cite links in orgmode
  ; we need to be sure there is a bibliography defined
;  (if (not (reftex-default-bibliography))
;      (setq reftex-default-bibliography (cite-find-bibliography)))
  ; define a convenient key for adding citations
  (define-key org-mode-map (kbd "C-c ]") 'reftex-citation))

;(add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_SRC

** TODO feedback function					   :noexport:
this may be superceded by org-annotation. also it should insert the relative path, not absolute path in teh output
#+BEGIN_SRC emacs-lisp
(defun insert-feedback (note)
  "insert a note in feedback.org with the file and line-number."
  (interactive "sNote: ")
  (let ((current-point (point))
        (current-line (line-number-at-pos))
        (current-file-name (buffer-file-name)))
    (find-file-other-window "feedback.org")

    (goto-char (point-max))
    (org-return-indent)

    (insert
    (format "[[elisp:(progn (find-file \"%s\")(goto-char %i))][%s:%i]]: %s"
     current-file-name
     current-point
     (file-name-nondirectory current-file-name)
     current-line note))
    (save-buffer)
    (other-window 1)))

(global-set-key "\C-ci" 'insert-feedback)
#+END_SRC

** org-annotation						   :noexport:
#+BEGIN_SRC emacs-lisp :tangle org-annotate-file.el
;;; org-annotate-file.el --- Annotate a file with org syntax

;; Copyright (C) 2008-2012 Philip Jackson

;; Author: Philip Jackson <phil@shellarchive.co.uk>
;; Version: 0.2

;; This file is not currently part of GNU Emacs.

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 2, or (at
;; your option) any later version.

;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;; General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program ; see the file COPYING.  If not, write to
;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
;; Boston, MA 02111-1307, USA.

;;; Commentary:

;; This is yet another implementation to allow the annotation of a
;; file without modification of the file itself. The annotation is in
;; org syntax so you can use all of the org features you are used to.

;; To use you might put the following in your .emacs:
;;
;; (require 'org-annotate-file)
;; (global-set-key (kbd "C-c C-l") 'org-annotate-file) ; for example
;;
;; To change the location of the annotation file:
;;
;; (setq org-annotate-file-storage-file "~/annotated.org")
;;
;; Then when you visit any file and hit C-c C-l you will find yourself
;; in an org buffer on a headline which links to the file you were
;; visiting, e.g:

;; * ~/org-annotate-file.el

;; Under here you can put anything you like, save the file
;; and next time you hit C-c C-l you will hit those notes again.
;;
;; To put a subheading with a text search for the current line set
;; `org-annotate-file-add-search` to non-nil value. Then when you hit
;; C-c C-l (on the above line for example) you will get:

;; * ~/org-annotate-file.el
;; ** `org-annotate-file-add-search` to non-nil value. Then whe...

;; Note that both of the above will be links.

(require 'org)

(defvar org-annotate-file-storage-file "~/.org-annotate-file.org"
  "File in which to keep annotations.")

(defvar org-annotate-file-add-search nil
  "If non-nil then add a link as a second level to the actual
location in the file")

(defvar org-annotate-file-always-open t
  "non-nil means always expand the full tree when you visit
`org-annotate-file-storage-file'.")

(defun org-annotate-file-elipsify-desc (string &optional after)
  "Strip starting and ending whitespace and replace any chars
that appear after the value in `after' with '...'"
  (let* ((after (number-to-string (or after 30)))
         (replace-map (list (cons "^[ \t]*" "")
                            (cons "[ \t]*$" "")
                            (cons (concat "^\\(.\\{" after
                                          "\\}\\).*") "\\1..."))))
    (mapc (lambda (x)
            (when (string-match (car x) string)
              (setq string (replace-match (cdr x) nil nil string))))
          replace-map)
    string))

(defun org-annotate-file ()
  "Put a section for the current file into your annotation file"
  (interactive)
  (unless (buffer-file-name)
    (error "This buffer has no associated file"))
  (org-annotate-file-show-section))

(defun org-annotate-file-show-section (&optional buffer)
  "Visit the buffer named `org-annotate-file-storage-file' and
show the relevant section"
  (let* ((filename (abbreviate-file-name (or buffer (buffer-file-name))))
         (line (buffer-substring-no-properties (point-at-bol) (point-at-eol)))
         (link (org-make-link-string (concat "file:" filename) filename))
         (search-link (org-make-link-string
                       (concat "file:" filename "::" line)
                               (org-annotate-file-elipsify-desc line))))
    (with-current-buffer (find-file org-annotate-file-storage-file)
      (unless (eq major-mode 'org-mode)
        (org-mode))
      (goto-char (point-min))
      (widen)
      (when org-annotate-file-always-open
        (show-all))
      (unless (search-forward-regexp
               (concat "^* " (regexp-quote link)) nil t)
        (org-annotate-file-add-upper-level link))
      (beginning-of-line)
      (org-narrow-to-subtree)
      ;; deal with a '::' search if need be
      (when org-annotate-file-add-search
        (unless (search-forward-regexp
                 (concat "^** " (regexp-quote search-link)) nil t)
          (org-annotate-file-add-second-level search-link))))))

(defun org-annotate-file-add-upper-level (link)
  (goto-char (point-min))
  (call-interactively 'org-insert-heading)
  (insert link))

(defun org-annotate-file-add-second-level (link)
  (goto-char (point-at-eol))
  (call-interactively 'org-insert-subheading)
  (insert link))

(provide 'org-annotate-file)

;;; org-annotate-file.el ends here

#+END_SRC

** TODO bookmarklet to remember webpages
http://orgmode.org/worg/org-contrib/org-annotation-helper.html
http://orgmode.org/worg/org-contrib/org-protocol.html
** TODO org-registry
   http://orgmode.org/w/?p=org-mode.git;a=blob_plain;f=contrib/lisp/org-registry.el;hb=HEAD
* blog
#+BEGIN_SRC emacs-lisp
(load-file (concat starter-kit-dir "jekyll-blog.el"))
#+END_SRC
* TODO python
Support for the Python programming language.
** Use Python's python-mode.el instead of Emacs' python.el
   :PROPERTIES:
   :CUSTOM_ID: python
   :END:

Replace the Python mode that comes with Emacs by the Python mode
supplied by the Python distribution itself.

#+begin_src emacs-lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; python-mode 5.2
;(setq org-babel-python-command "ipython"
;      py-python-command "ipython"
;      py-python-command-args '("-pylab" "-colors" "LightBG"))

(setq org-babel-python-command "python"
      py-python-command "python")

(load-file (concat starter-kit-dir "python-mode-5.2.el"))
(require 'python-mode)


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; emacs python mode
;; (require 'python)
;; (setq org-babel-python-mode 'python)
;; (setq-default indent-tabs-mode nil)    ; use only spaces and no tabs
;; (setq default-tab-width 4)

;; ;; Auto Completion
;; (require 'auto-complete-config)
;; (add-to-list 'ac-dictionary-directories 
;; 	     (concat starter-kit-dir "auto-complete/ac-dict"))
;; (ac-config-default)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; emacs-for-python
;; (load-file (concat starter-kit-dir "/emacs-for-python/epy-init.el"))
#+end_src

#+RESULTS:

** Code checking option 1: On-the-fly w/ Flymake
http://www.saltycrane.com/blog/2010/05/my-emacs-python-environment/

#+begin_src emacs-lisp
(add-hook 'find-file-hook 'flymake-find-file-hook)
(when (load "flymake" t)
  (defun flymake-pyflakes-init ()
    (let* ((temp-file (flymake-init-create-temp-buffer-copy
               'flymake-create-temp-inplace))
       (local-file (file-relative-name
            temp-file
            (file-name-directory buffer-file-name))))
      (list "pycheckers"  (list local-file))))
   (add-to-list 'flymake-allowed-file-name-masks
             '("\\.py\\'" flymake-pyflakes-init)))
;(require 'flymake-cursor)
(global-set-key [f10] 'flymake-goto-prev-error)
(global-set-key [f11] 'flymake-goto-next-error)
#+end_src

You need this shell script.
#+begin_src sh :tangle ~/bin/pycheckers
#!/bin/bash
pyflakes "$1"
pep8 --ignore=E221,E701,E202 --repeat "$1"
true
#+end_src
* jmax lisp
** line-spacing
#+BEGIN_SRC emacs-lisp
;; http://sdpconfig.wordpress.com/2011/12/21/unwrapping-paragraphs-in-emacs/
(defun unfill-paragraph ()
  "Unfill paragraph at or after point."
  (interactive "*")
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph nil (region-active-p))))

(defun double-space ()
  "make buffer look approximately double-spaced"
  (interactive)
  (setq line-spacing 10))

(defun single-space ()
  "make buffer single-spaced"
  (interactive)
  (setq line-spacing nil))
#+END_SRC

** get paths and insert functions
*************** TODO convert insert path to use a prefix arg for relative/absolute paths.
*************** END

#+BEGIN_SRC emacs-lisp
;http://www.gnu.org/software/emacs/manual/html_node/elisp/File-Name-Expansion.html#File-Name-Expansion

(defun get-path()
  "opens dired so you can navigate to a file to insert a path to it in the current buffer"
  (interactive)
  ; store current buffer so we can change back to it
  (setq current_buffer (current-buffer))
  (setq buffer_name (buffer-file-name))
  ; now call dired to navigate to the path you want
  (dired ())
)

(defun insert-relative-path()
  "inserts the relative path between the original buffer and current file selected in dired"
  (interactive)
  (setq selected_file (dired-get-filename))
  (switch-to-buffer current_buffer) ; back to the original buffer
  (insert  (file-relative-name selected_file));inserts relative path
)

(defun insert-absolute-path()
  "Inserts the absolute path to the file selected in dired"
  (interactive)
  (setq selected_file (dired-get-filename)) ; this is the file the cursor is on
  (switch-to-buffer current_buffer) ; back to the original buffer
  (insert  (expand-file-name selected_file));inserts absolute path
)

(defun insert-buffer-filename()
  "Inserts filename associated with current buffer"
  (interactive)
  (insert (buffer-file-name))
)

(global-set-key "\C-cg" 'get-path )
(global-set-key "\C-cp" 'insert-relative-path)
(global-set-key "\C-cf" 'insert-buffer-filename)
#+END_SRC

** help search functions
#+BEGIN_SRC emacs-lisp
;; http://davidavraamides.net/blog/2008/07/22/mode-aware-google-help-in-emacs/
(defun search-site-url (keyword &optional site inurl lucky)
  "Do a Google search for KEYWORD. Restrict to SITE and INURL, if specified.
Jump to best match (I Feel Lucky) if LUCKY set.
"
  (concat "http://www.google.com/"
          (format "search?q=%s" (url-hexify-string keyword))
          (if site (format "+site:%s" (url-hexify-string site)))
          (if inurl (format "+inurl:%s" (url-hexify-string inurl)))
          (if lucky "&btnI")))

(defun context-help ()
  "Open a browser window showing documentation for the word under the point.
Uses `major-mode' to optionally refine the search to a specific web site,
or a specific pattern in the URL. Defaults to a simple keyword search.
Uses `search-site-url' to do the actual search.
"
  (interactive)
  (require 'url)
  (browse-url
   (apply 'search-site-url
          (thing-at-point 'symbol)
          (cond
            ((equal major-mode 'css-mode)
             '("www.w3schools.com" "/css/" t))
            ((equal major-mode 'emacs-lisp-mode)
             '("www.gnu.org" "/emacs/"))
            ((or (equal major-mode 'html-mode)
                 (equal major-mode 'html-helper-mode))
             '("www.htmlquick.com" "/reference/" t))
            ((equal major-mode 'javascript-mode)
             '("www.w3schools.com" nil t))
            ((equal major-mode 'python-mode)
             '("docs.python.org" "/ref/" t))
	    ((equal major-mode 'vasp-mode)
	     '("http://cms.mpi.univie.ac.at" "/vasp/vasp/" t))
            (t nil)))))
#+END_SRC

** system interactions
#+BEGIN_SRC emacs-lisp
;; I think these would eventually get moved to a major mode
(defun run-cat ()
  "example function to run a shell command on  a a filename"
  (interactive)
  (shell-command (concat "cat" " " (buffer-file-name))))

(defun ncsum ()
  "runs ncsum on the current file in dired"
  "the filename should be a netcdf file, although no checks are performed."
  (interactive)
  (dired-do-shell-command "ncsum" nil (list (dired-get-filename))))

(defun ag ()
  "runs ag on the current file in dired"
  "the filename should be a file ag can read, although no checks are performed."
  (interactive)
  (dired-do-shell-command "ag" nil (list (dired-get-filename))))
#+END_SRC

** create a blog post
#+BEGIN_SRC emacs-lisp
; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; To export my site I just run C-c e X blog.
;(add-to-list 'load-path (concat starter-kit-dir "/org-jekyll"))
;(require 'org-jekyll)
(setq org-publish-project-alist '())
;; (setq org-publish-project-alist
;;              '("jekyll-blog"
;;                :base-directory "~/org-mode/blog/"
;;                :recursive t
;;                :base-extension "org"
;;                :publishing-directory "~/blog/gh-pages/"
;;                :exclude "^blog\\|^bitacora"
;;                :site-root "http://http://jkitchin.github.com"
;;                :jekyll-sanitize-permalinks t
;;                :publishing-function org-publish-org-to-html
;;                :section-numbers nil
;;                :headline-levels 4
;;                :table-of-contents t
;;                :auto-index nil
;;                :auto-preamble nil
;;                :body-only t
;;                :auto-postamble nil))

;; (add-to-list 'org-publish-project-alist
;;              '("jekyll-blog-img"
;;                :base-directory "~/org-mode/blog/"
;;                :recursive t
;;                :exclude "^publish"
;;                :base-extension "jpg\\|gif\\|png"
;;                :publishing-directory "~/blog/gh-pages/"
;;                :publishing-function org-publish-attachment))

;; (add-to-list 'org-publish-project-alist
;;              '("jekyll-blog" :components ("jekyll-blog"  "jekyll-blog-img")))


;; (add-to-list 'org-publish-project-alist
;;       '("blog-posts"
;;          ;org -files location and extension
;;          :base-directory "~/org-mode/blog"
;;          :base-extension "org"  ; files named foo.org

;;           ;; Path to your Jekyll project.
;;           :publishing-directory "~/blog/gh-pages/"
;;           :recursive t
;;           :publishing-function org-publish-org-to-html
;;           :headline-levels 4
;;           :html-extension "html"
;;           :body-only t)) ;; Only export section between <body> </body>

;; (add-to-list 'org-publish-project-alist
;;         '("blog" :components ("blog-posts")))

;; (require 'org-publish)
;; (add-to-list 'org-publish-project-alist
;;              '("org-jekyll-posts"
;;                :base-directory "c:/Users/jkitchin/Dropbox/.emacs.d/org-jekyll/test"
;;                :recursive t
;;                :base-extension "org"
;;                :publishing-directory "c:/Users/jkitchin/Dropbox/.emacs.d/org-jekyll/"
;;                :publishing-function org-publish-org-to-html
;;                :section-numbers nil
;;                :headline-levels 4
;;                :table-of-contents nil
;;                :auto-index nil
;;                :auto-preamble nil
;;                :body-only t
;;                :auto-postamble nil))

;; ; get the images where we want them
;; (add-to-list 'org-publish-project-alist
;;              '("org-jekyll-images"
;;                :base-directory "c:/Users/jkitchin/Dropbox/.emacs.d/org-jekyll/test"
;;                :recursive t
;;                :exclude "^publish"
;;                :base-extension "jpg\\|gif\\|png"
;;                :publishing-directory "c:/Users/jkitchin/Dropbox/.emacs.d/org-jekyll/_posts"
;;                :publishing-function org-publish-attachment))

;; (add-to-list 'org-publish-project-alist
;;              '("org-jekyll-test" :components ("org-jekyll-posts" "org-jekyll-images")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; jkitchin.github.com
;; this block creates posts
(add-to-list 'org-publish-project-alist
             '("jkitchin-posts"
               :base-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/_org"
               :recursive t
               :base-extension "org"
               :publishing-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/_posts/"
               :publishing-function org-publish-org-to-html
               :section-numbers nil
               :headline-levels 4
               :table-of-contents nil
               :auto-index nil
               :auto-preamble nil
               :body-only t
               :auto-postamble nil))

;; this grabs everything else not in the _org directory.
(add-to-list 'org-publish-project-alist
             '("jkitchin-pages"
               :base-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source"
               :exclude "^_org"
               :recursive t
               :base-extension "org"
               :publishing-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/"
               :publishing-function org-publish-org-to-html
               :section-numbers nil
               :headline-levels 4
               :table-of-contents nil
               :auto-index nil
               :auto-preamble nil
               :body-only t
               :auto-postamble nil))

; I want to have the raw org files moved over too
;(add-to-list 'org-publish-project-alist
;             '("jkitchin-org"
;               :base-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/_org"
;               :recursive t
;               :exclude "^publish"
;               :base-extension "org"
;               :publishing-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/org"
;               :publishing-function org-publish-attachment))

; get the images where we want them, in the images directory.
(add-to-list 'org-publish-project-alist
             '("jkitchin-images"
               :base-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/_org"
               :recursive t
               :exclude "^publish"
               :base-extension "jpg\\|gif\\|png"
               :publishing-directory "/home/jkitchin/Dropbox/jkitchin.github.com/source/images"
               :publishing-function org-publish-attachment))

(add-to-list 'org-publish-project-alist
             '("jkitchin" :components ("jkitchin-posts" "jkitchin-pages" "jkitchin-images")))

(org-add-link-type
 "img"
 (lambda (keyword)
   (find-file keyword)) ; open the file
 (lambda (keyword link format)
   (cond
    ((eq format 'html)
     (format "<img src=\"http://jkitchin.github.com/images/%s\">" keyword)))))


(defun new-blog-post (title &optional directory)
  "create a new blog post with name year-month-day-title.org.
If C-u called first, then create a directory with the title name, and
a buffer inside the directory. The buffer is pre-formatted for jekyll blog posts."
  (interactive
   (cond
    ((equal current-prefix-arg nil) ; universal argument not called
     (message "no prefix arg")
     (list
      ; first read title, and set directory to nil
      (read-string "Title: " nil nil "span") nil))
    ((equal current-prefix-arg '(4)) ; C-u was called
     ; first read title, and set directory to t
     (list (read-string "Title: " nil nil "span") t))))
  (if directory
      ; directory is true, so create one
      (progn
        (message "making a directory")
        (make-directory (format "%s-%s"
                                (format-time-string "%Y-%m-%d")
                                (replace-regexp-in-string " " "-" title)) t)
        (message "made a directory")
        (setq post-buffer
              (format "%s-%s/%s-%s.org"
                      (format-time-string "%Y-%m-%d")
                      (replace-regexp-in-string " " "-" title)
                      (format-time-string "%Y-%m-%d")
                      (replace-regexp-in-string " " "-" title)))
        (find-file post-buffer))
    (progn
      (setq post-buffer
           (format "%s-%s.org"
            (format-time-string "%Y-%m-%d")
            (replace-regexp-in-string " " "-" title)))
     (find-file post-buffer)))
  ;; now insert the header stuff required for jekyll
  (insert (format "#+begin_html
---
layout: post
title: %s
tags:
categories:
---
,#+end_html

" title)))
#+END_SRC

* TODO send email through gmail
Adapted from http://wideaperture.net/blog/?p=3343

#+begin_src emacs-lisp
;;Configure Outbound Mail
;;Tell Emacs to use GNUTLS instead of STARTTLS
;;to authenticate when sending mail.
(setq starttls-use-gnutls t)

;;Tell Emacs about your mail server and credentials
(setq send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials
      '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials
      (expand-file-name "~/.authinfo")
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)
(require 'smtpmail)
#+end_src


* TODO setup gnus for reading and sending mail
Note: this is not working completely yet.

you need to create ~/.imap-authinfo see http://emacswiki.org/emacs/GnusAuthinfo

It has a format like this:
#+begin_example
machine imap.gmail.com login john_doe@gmail.com password notapassword port 993
#+end_example

#+begin_src emacs-lisp  :tangle no
;; Customize the next three lines with your ISP information.
(load "starttls")
(load-library "smtpmail")

;; Configure incoming mail (IMAP)
(setq gnus-select-method '(nnimap "gmail"
(nnimap-address "imap.gmail.com")
(nnimap-server-port 993)

; you need to create ~/.imap-authinfo see http://emacswiki.org/emacs/GnusAuthinfo
(nnimap-authinfo-file "~/.imap-authinfo")
(nnimap-stream ssl)))

;; Configure outbound mail (SMTP)
(setq smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-default-smtp-server "smtp.gmail.com"
      send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-smtp-service 587
      smtpmail-auth-credentials '(("smtp.gmail.com" 587 user-mail-address nil))
      smtpmail-debug-info t
      smtpmail-debug-verb t
      )
(setq smtpmail-local-domain nil)
(setq gnus-permanently-visible-groups "gmail")
(executable-find starttls-program)
#+end_src


#+begin_src emacs-lisp 
(setq gnus-select-method '(nntp "news.gmane.org"))
#+end_src

* ebib setup							   :noexport:
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat starter-kit-dir "./ebib"))
(autoload 'ebib "ebib" "Ebib, a BibTeX database manager." t)
#+END_SRC

#+RESULTS:
| autoload | ebib | Ebib, a BibTeX database manager. | t | nil |



* magit
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat starter-kit-dir "/magit-1.2.0/"))
(require 'magit)

(global-set-key "\C-cm" 'magit-status)
#+END_SRC

#+RESULTS:

