#+TITLE: Emacs customizations to maximize John's Emacs
#+TITLE:     jmax.org
#+AUTHOR:    John Kitchin
#+EMAIL:     jkitchin@cmu.edu
#+DATE:      2012-12-12 Wed
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+OPTIONS:   H:3 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:
#+LINK_HOME:
#+XSLT:

* tasks
empty

* personal setup                                                   :personal:
Obviously this will have to be customized.

#+begin_src emacs-lisp
;; I need some lisp voodoo here to set paths according to the machine I am on.
(when (or (string= system-name "jkitchin-780.cheme.cmu.edu")
	  (string= system-name "gilgamesh.cheme.cmu.edu"))
  (defvar my-aspell "aspell"))

(when (or (string= system-name "JKITCHIN-PC")
	  (string= system-name "KITCHIN-TABLET"))
  (defvar my-aspell "C:/Program Files/Aspell/bin/aspell.exe"))

(when (or (string= system-name "HOME-OFFICE")
          (string= system-name "JKITCHIN-2012"))
       (defvar my-aspell "C:/Program Files (x86)/Aspell/bin/aspell.exe"))

;;Tell the program who you are
(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")
#+end_src

#+RESULTS:

* Basic customizations
#+BEGIN_SRC emacs-lisp
(setq frame-title-format "jmax - awesome editing")
(tool-bar-mode 0) ; remove the icons
(menu-bar-mode 1) ; keep the menus
(global-visual-line-mode 1) ;; how long lines are handled.
                            ;; This appears to wrap long lines

(global-font-lock-mode t)   ;; turn on font-lock mode everywhere

(show-paren-mode 1)         ;; highlight parentheses
(setq show-paren-style 'parenthesis) ;; alternative is 'parenthesis

(line-number-mode 1)  ;; turn linumbers on in mode-line
;(global-linum-mode t) ;; put line numbers on left side of the screen

(setq backup-inhibited t)  ;; disable backup file creation

(setq inhibit-startup-screen t) ;; stop showing startup screen

(fset 'yes-or-no-p 'y-or-n-p) ; answer with y/n instead of yes/no

(global-set-key [f9] (lambda () (interactive) (save-buffer) (load-file (concat starter-kit-dir "/init.el"))))
#+END_SRC

#+RESULTS:
| lambda | nil | (interactive) | (save-buffer) | (load-file (concat starter-kit-dir /init.el)) |

** abbrev mode
#+begin_src emacs-lisp
(abbrev-mode 1) ; turn abbrev mode on
(setq-default abbrev-mode t)
(setq abbrev-file-name (concat starter-kit-dir "abbrev_defs"))
(if (not (file-exists-p abbrev-file-name))
(progn (find-file-no-select abbrev-file-name) (write-file abbrev-file-name))
)
(read-abbrev-file (concat starter-kit-dir "abbrev_defs"))
(setq save-abbrevs t)
#+end_src

#+RESULTS:

** packages to always load
#+begin_src emacs-lisp
  (require 'cl)           ;; common-lisp functions

  (require 'saveplace)     ;; When you visit a file, point goes to the
                           ;; last place where it was when you
                           ;; previously visited the same file.

  (require 'ffap)          ;; find-file-at-point

  (require 'uniquify)      ;; overrides Emacs' default mechanism for
                           ;; making buffer names unique (using suffixes
                           ;; like <2>, <3> etc.) with a more sensible
                           ;; behaviour which use parts of the file
                           ;; names to make the buffer names
                           ;; distinguishable.

  (require 'ansi-color)    ;; translates ANSI SGR (Select Graphic
                           ;; Rendition) escape sequences like "Esc [ 30
                           ;; m" into EmacsOverlays, TextProperties, or
                           ;; XEmacsExtents with face colours, bold,
                           ;; etc.

  (require 'recentf)       ;; Toggles "Open recent" menu
  (require 'eieio)
#+end_src

* Setup package manager
#+begin_src emacs-lisp
;;   (setq package-archives
;;         '(("gnu"         . "http://elpa.gnu.org/packages/")
;;           ("original"    . "http://tromey.com/elpa/")
;;           ("org"         . "http://orgmode.org/elpa/")
;;           ("marmalade"   . "http://marmalade-repo.org/packages/")))
;;   (package-initialize)

;; (setq package-user-dir (concat starter-kit-dir "/elpa"))

;;   (defvar starter-kit-packages
;;     (list 'yasnippet-bundle
;;           'magit)
;;     "Libraries that should be installed by default.")

;;   (unless package-archive-contents
;;     (package-refresh-contents))

;;   (dolist (package starter-kit-packages)
;;     (unless (package-installed-p package)
;;       (package-install package)))
#+end_src

#+RESULTS:

* color theme
#+BEGIN_SRC emacs-lisp
(add-to-list 'custom-theme-load-path (concat starter-kit-dir "/themes"))
(load-theme 'my t)
#+END_SRC

#+RESULTS:
: t

* auto-complete
see: http://cx4a.org/software/auto-complete/manual.html
#+begin_src emacs-lisp
(add-to-list 'load-path (concat starter-kit-dir "/auto-complete-1.3.1"))
(require 'auto-complete-config)
(add-to-list 'ac-dictionary-directories (concat starter-kit-dir "/auto-complete-1.3.1/ac-dict"))
(ac-config-default)
#+end_src

* spell-checking
#+begin_src emacs-lisp
(require 'ispell)
(setq flyspell-issue-welcome-flag nil)
(global-set-key (kbd "<f8>") 'ispell-word)
(global-set-key (kbd "C-<f8>") 'flyspell-mode)
(flyspell-mode t)

(setq-default ispell-program-name my-aspell)
(setq ispell-personal-dictionary (concat starter-kit-dir "/.ispell"))
(setq text-mode-hook '(lambda()
			(flyspell-mode t)       ; spellchek (sic) on the fly
			))
;;(setq ispell-personal-dictionary (concat starter-kit-dir "Dropbox/.emacs.d/.ispell"))

;; stop annoying boxes from popping up when no makefile foundx
(setq flymake-gui-warnings-enabled nil)
#+end_src
* org-mode
#+BEGIN_SRC emacs-lisp
(require 'org)
(require 'org-special-blocks)
(require 'org-inlinetask)
;(require 'org-latex)

(add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode))
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cb" 'org-iswitchb)
(global-set-key [f12] 'org-mode)

(global-set-key "\C-e" 'end-of-line); overwrites org-mode \C-e definition

(global-set-key "\C-cL" 'org-insert-link-global)
(global-set-key "\C-co" 'org-open-at-point-global)

; I like to press enter to follow a link. mouse clicks also work.
(setq org-return-follows-link t)
#+END_SRC

** basic setup
#+BEGIN_SRC emacs-lisp
; use syntax highlighting in org-file code blocks
(setq org-src-fontify-natively t)

; do not evaluate code on export by default
(setq org-export-babel-evaluate nil)

; enable prompt-free code running
(setq org-confirm-babel-evaluate nil)

; register python in org-mode
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)))

; no extra indentation
(setq org-src-preserve-indentation t)
(setq org-startup-with-inline-images "inlineimages")
#+END_SRC
** default output for code blocks
#+BEGIN_SRC emacs-lisp
; set default :results to output
(setq org-babel-default-header-args
      (cons '(:results . "replace output")
	    (assq-delete-all :results org-babel-default-header-args)))

; set default exports to both code and results
(setq org-babel-default-header-args
      (cons '(:exports . "both")
	    (assq-delete-all :exports org-babel-default-header-args)))
#+END_SRC
** reftex setup
This allows you insert citations from reftex. I am not sure I like this a lot, as I prefer the citations to go in as links. I think this can be done via ebib, or I will one day write my own insert citation function that puts in the links I want like these [[cite links]].

#+BEGIN_SRC emacs-lisp
(defun org-mode-reftex-setup ()
  (load-library "reftex")
  (and (buffer-file-name)
       (file-exists-p (buffer-file-name))
       (reftex-parse-all))
  (define-key org-mode-map (kbd "C-c )") 'reftex-citation))

(add-hook 'org-mode-hook 'org-mode-reftex-setup)
#+END_SRC

** publishing setup
#+BEGIN_SRC emacs-lisp
(setq org-export-latex-default-packages-alist
      (quote
       (("AUTO" "inputenc" t)
	("" "fixltx2e" nil)
	("" "url")
	("" "graphicx" t)
	("" "minted" t)
	("" "color" t)
	("" "longtable" nil)
	("" "float" nil)
	("" "wrapfig" nil)
	("" "soul" t)
	("" "textcomp" t)
	("" "amsmath" t)
	("" "marvosym" t)
	("" "wasysym" t)
	("" "latexsym" t)
	("" "amssymb" t)
	("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)
	("" "attachfile" t)
	"\\tolerance=1000")))

; this is for code syntax highlighting
(setq org-export-latex-listings 'minted)

(setq org-export-latex-minted-options
           '(("frame" "lines")
             ("fontsize" "\\scriptsize")
             ("linenos" "")))

; for minted you must run latex with -shell-escape because it calls pygmentize as an external program
(setq org-latex-to-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "bibtex %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
#+END_SRC
** org-mode links
*** pydoc
#+BEGIN_SRC emacs-lisp
; here is a way to get pydoc in a link: [[pydoc:numpy]]
(setq org-link-abbrev-alist
      '(("pydoc" . "shell:pydoc %s")))
#+END_SRC

#+BEGIN_SRC emacs-lisp
;; these allow me to write mod:numpy or func:numpy.dot to get
;; clickable links to documentation
(org-add-link-type
 "mod"
 (lambda (arg)
   (shell-command (format "pydoc %s" arg) nil))
 (lambda (path desc format)
   (cond
    ((eq format 'latex)
     (format "\\texttt{%s}" path)))))

(org-add-link-type
 "func"
 (lambda (arg)
   (shell-command (format "pydoc %s" arg) nil))
 (lambda (path desc format)
   (cond
    ((eq format 'latex)
     (format "\\texttt{%s}" path)))))
#+END_SRC

*** links to microsoft files
#+BEGIN_SRC emacs-lisp
;;; support for links to microsoft docx,pptx,xlsx files
;;; standard org-mode opens these as zip-files
;;  http://orgmode.org/manual/Adding-hyperlink-types.html
(org-add-link-type "msx" 'org-msx-open)

(defun org-msx-open (path)
       "Visit the msx file on PATH.

uses the dos command:
start  empty title path
"
       (shell-command
	(concat "start \"title\" " (shell-quote-argument path)) t))
#+END_SRC

*** asynchronous shell commands
#+BEGIN_SRC emacs-lisp
(org-add-link-type "ashell" 'org-ashell-open)
(defun org-ashell-open (cmd)
"open an ashell:cmd link
[[ashell:xterm -e \"cd 0; ls && /bin/bash\"]]

I use this to run commands asynchronously in the shell. org-mode runs shell links in a blocking mode, which is annoying when you open an xterm."
(start-process-shell-command "ashell" "*scratch*" cmd))
#+END_SRC

*** colored text
#+BEGIN_SRC emacs-lisp
;; -*- emacs-lisp -*-   [[color:red][in red]]
(org-add-link-type
 "color"
 (lambda (path)
   (message (concat "color "
		    (progn (add-text-properties
			    0 (length path)
			    (list 'face `((t (:foreground ,path))))
			    path) path))))
 (lambda (path desc format)
   (cond
    ((eq format 'html)
     (format "<span style=\"color:%s;\">%s</span>" path desc))
    ((eq format 'latex)
     (format "{\\color{%s}%s}" path desc)))))
#+END_SRC

*** VASP incar keyword link
#+BEGIN_SRC emacs-lisp
;; -*- emacs-lisp -*-   [[incar:keyword]]
;; this makes nice links in org-mode to the online documentation and
;; renders useful links in output
;;
;; (org-add-link-type TYPE &optional FOLLOW EXPORT)
;; FOLLOW is the function that takes the path and does what is
;; necessary to "follow" the link.
;; EXPORT takes three args
;;  path the path of the link, the text after the prefix (like "http:")
;;
;;  desc the description of the link, if any, or a
;;  description added by org-export-normalize-links if there is none
;;
;;  format the export format, a symbol like `html' or `latex' or
;;  `ascii'..
(org-add-link-type "incar"
;; FOLLOW code
  (lambda (keyword)
    (shell-command (format "firefox http://cms.mpi.univie.ac.at/wiki/index.php/%s" keyword) nil))
;; FORMAT code
  (lambda (keyword description format)
   (cond
    ((eq format 'html)
     (format "<a href=http://cms.mpi.univie.ac.at/wiki/index.php/%s>%s</a>" keyword keyword))
    ((eq format 'latex)
     (format "\\href{http://cms.mpi.univie.ac.at/wiki/index.php/%s}{%s}"  keyword keyword)
))))
#+END_SRC

*** experimental image link
This was to have a way to put a single file name into an org-file, but get the right figure type for different outputs, e.g. png for html, and pdf for pdflatex
#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "image"
 (lambda (keyword)
   ()) ; do nothing. maybe figure out how to open a png or pdf
 (lambda (keyword link format)
   (cond
    ((eq format 'latex)
     (format "\\includegraphics{%s.pdf}" keyword)))))
#+END_SRC

*** citeulike link
This adds a way to link to articles in citeulike. The syntax is citeu:11819912 or [[citeu:11819912, 11819910]]. The link exports as urls in brackets in html and as superscripted urls in latex. In org-mode if you click on the key, it will launch a browser opening to that article.

Known limitations: if they key is not recognized as a word by emacs, the clicking will not work as expected. eg. if your key is something like j:345, this is not recognized as a word by emacs.

#+BEGIN_SRC emacs-lisp
(require 'thingatpt)

(defvar citeu-user "jkitchin"
  "The username for your citeulike account")

(defvar citeu-url (format
                   "http://www.citeulike.org/user/%s/article/"
                   citeu-user)
  "the url that points to an article in citeulike. you add a key to the end to get a specific article.")

(defun citeu-strip-key (key)
  "strip leading and trailing whitespace from the key"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" key) ))

(defun citeu-split-keys (key-string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'citeu-strip-key (split-string key-string ",")))

(defun citeu-visit-key-at-point (arg)
  "find key at point and open a browser to the corresponding citeulike page"
  (let ((key (word-at-point)))
  (browse-url (concat citeu-url key))))

(defun citeu-make-html-link (stripped-key)
  "construct one href link from a stripped-key."
  (let ((href (concat citeu-url stripped-key)))
    (concat "<a href=\"" href "\">" stripped-key "</a>")))

(defun citeu-make-html-links (stripped-keys)
  "combine all links in brackets and output the html code"
  (interactive)
  (concat "[" (mapconcat 'citeu-make-html-link stripped-keys ", ") "]"))

(defun citeu-make-latex-link (stripped-key)
  "make a latex link from a stripped key"
  (let ((href (concat citeu-url stripped-key)))
     (concat "{\\href{" href"}{" stripped-key "}")))

(defun citeu-make-latex-links (stripped-keys)
  "construct links as superscripted bracketed links in latex"
  (interactive)
  (concat "$^{[" (mapconcat 'citeu-make-latex-link stripped-keys ", ") "]$"))

(org-add-link-type "citeu"
  ; visit the key the cursor is on when clicked or Entered
  'citeu-visit-key-at-point
  ; formatting
  (lambda (keyword desc format)
    (cond
     ((eq format 'html)
      (citeu-make-html-links (citeu-split-keys keyword)))
     ((eq format 'latex)
      (citeu-make-latex-links (citeu-split-keys keyword)))
      )))
#+END_SRC

*** cite links

#+BEGIN_SRC emacs-lisp
;;;;;;;;;;;;
;; implemenation of cite:  to make bibtex citations that are also clickable.
;; similar to the citeu link, you can click on one key and open that bibtex entry

(defun cite-find-bibliography ()
  "find the bibliography file(s) in the buffer

search for [[bibliography:()]]
and extract out what is in the () with a regexp

returns a list of stripped file names"
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "bibliography:\\([^\]\|\n]+\\)")
    (setq cite-bibliography-files
          (mapcar 'citeu-strip-key (split-string (match-string 1) ",")))))

(defun cite-goto-bibentry (bibfile key)
  "open bibfile in another window at the key"
  (interactive)
  (find-file-other-window bibfile)
  (goto-char (point-min)) ; always start search from beginning.
  (re-search-forward key nil t 1))

(defun cite-strip-key (key)
  "strip leading and trailing whitespace from the key"
  (interactive)
  (replace-regexp-in-string
   (concat search-whitespace-regexp "$" ) ""
   (replace-regexp-in-string
    (concat "^" search-whitespace-regexp ) "" key) ))

(defun cite-split-keys (key-string)
  "split key-string and strip keys. Assumes the key-string is comma delimited"
  (mapcar 'citeu-strip-key (split-string key-string ",")))

(defun cite-make-latex-links (stripped-keys)
  "construct links as superscripted bracketed links in latex"
  (interactive)
  (concat "\\cite{" (mapconcat (lambda (key) key) stripped-keys ",") "}"))

(defun cite-key-in-file-p (key filename)
  "determine if the key is in the file"
  (with-temp-buffer
    (insert-file-contents filename)
    (goto-char (point-min))
    (search-forward key nil t 1)))

(org-add-link-type
 "cite"
 (lambda (link-string)
   ;; This code opens the bibtex file containing the clicked on
   ;; key. First we find the boundaries of the link you clicked on,
   ;; then identify the key you clicked on.
   (save-excursion
     (beginning-of-line) ; search forward from beginning of the line
     (search-forward link-string nil t 1)
     (setq link-string-beginning (match-beginning 0))
     (setq link-string-end (match-end 0)))
   ;; now we want to search forward to next comma from point
   (save-excursion
     (if (search-forward "," link-string-end 1 1)
         (setq key-end (- (match-end 0) 1)) ; we found a match
       (setq key-end (point)))) ; no comma found so take the point
   ;; and backward to previous comma from point
   (save-excursion
     (if (search-backward "," link-string-beginning 1 1)
         (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
       (setq key-beginning (point)))) ; no match found
                                        ; save the key we clicked on.
   (setq bibtex-key (cite-strip-key (buffer-substring key-beginning key-end)))
   (message "(%s %s) p=%s %s %s: %s"
            link-string-beginning
            link-string-end
            (point)
            key-beginning
            key-end
            bibtex-key )
   ;; now we get the bibliography files
   (setq cite-bibliography-files (cite-find-bibliography))
   ;(message "%S" cite-bibliography-files))
   ;; now find the first bib file containing the key
   (setq bib-file (loop for file in cite-bibliography-files do
         (if (cite-key-in-file-p bibtex-key file) (return file))))
   ;; and finally, open the file at the key
   (cite-goto-bibentry bib-file  bibtex-key))
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (cite-make-latex-links (cite-split-keys keyword))))))

(setq reftex-cite-format "[[cite:%l]]")
#+END_SRC

Here we add links for the bibliography and bibliography style
#+begin_src emacs-lisp
;; link to hold a bibliography bibtex file. Mostly so I can click on the link and open the file.
;; TODO replace click code to open file at point.
(org-add-link-type "bibliography"
(lambda (link-string)
    (save-excursion
     (beginning-of-line) ; search forward from beginning of the line
     (search-forward link-string nil t 1)
     (setq link-string-beginning (match-beginning 0))
     (setq link-string-end (match-end 0)))
   ;; now we want to search forward to next comma from point
   (save-excursion
     (if (search-forward "," link-string-end 1 1)
         (setq key-end (- (match-end 0) 1)) ; we found a match
       (setq key-end (point)))) ; no comma found so take the point
   ;; and backward to previous comma from point
   (save-excursion
     (if (search-backward "," link-string-beginning 1 1)
         (setq key-beginning (+ (match-beginning 0) 1)) ; we found a match
       (setq key-beginning (point)))) ; no match found
                                        ; save the key we clicked on.
   (setq bibfile (cite-strip-key (buffer-substring key-beginning key-end)))
(find-file bibfile)) ; open file on click
;; formatting code
(lambda (keyword desc format)
  (cond
   ((eq format 'latex)
    ; write out the latex bibliography command
    (format "\\bibliography{%s}" (replace-regexp-in-string  ".bib" "" keyword))))))

(org-add-link-type "bibliographystyle"
(lambda (arg) (message "Nothing implemented for clicking here.")) ; open file on click
(lambda (keyword desc format)
  (cond
   ((eq format 'latex)
    ; write out the latex bibliography command
    (format "\\bibliographystyle{%s}" keyword)))))
#+end_src

*** ref and label links
The idea here is to create links for label and ref. The reason for these additions is to provide clickable links to the references and labels, along with the org-mode navigation to quickly go back to where you were. These links get formatted to \ref and \label for latex. They are not formatted for HTML export yet.

#+BEGIN_SRC emacs-lisp

(org-add-link-type
 "ref"
 (lambda (label)
   "on clicking goto the label. Navigate back with C-c &"
   (let ((n (count-matches (format "label:%s\\b" label) (point-min) (point-max) t)))
     (if (< n 1) (error (format "no matching label found for %s!" label)))
     (if (> n 1) (error (format "%d matches found for %s!" n label)))
   (org-mark-ring-push)
   (goto-char (point-min))
   (re-search-forward (format "label:%s\\b" label))
   (message "go back with `C-c &`")))
 ;formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\ref{%s}" keyword)))))

(org-add-link-type
 "label"
 (lambda (label)
   "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
   (count-matches (format "label:%s\\b" label) (point-min) (point-max) t))
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\label{%s}" keyword)))))
#+END_SRC
** feedback function
#+BEGIN_SRC emacs-lisp
(defun insert-feedback (note)
  "insert a note in feedback.org with the file and line-number."
  (interactive "sNote: ")
  (let ((current-point (point))
        (current-line (line-number-at-pos))
        (current-file-name (buffer-file-name)))
    (find-file-other-window "feedback.org")

    (goto-char (point-max))
    (org-return-indent)

    (insert
    (format "[[elisp:(progn (find-file \"%s\")(goto-char %i))][%s:%i]]: %s"
     current-file-name
     current-point
     (file-name-nondirectory current-file-name)
     current-line note))
    (save-buffer)
    (other-window 1)))

(global-set-key "\C-ci" 'insert-feedback)
#+END_SRC

* TODO python
Support for the Python programming language.
** Use Python's python-mode.el instead of Emacs' python.el
   :PROPERTIES:
   :CUSTOM_ID: python
   :END:

Replace the Python mode that comes with Emacs by the Python mode
supplied by the Python distribution itself.

#+begin_src emacs-lisp
;; (setq py-install-directory (concat starter-kit-dir "/python-mode/"))
;; (add-to-list 'load-path py-install-directory)
;; (add-to-list 'load-path (concat starter-kit-dir "/python-mode/completion/"))
;; (add-to-list 'load-path (concat starter-kit-dir "/python-mode/Pymacs/"))

;; (require 'python-mode)
;; (add-to-list 'auto-mode-alist '("\\.py\\'" . python-mode))
;; (add-to-list 'interpreter-mode-alist '("ipython" . python-mode))
;; (setq py-shell-name "ipython")
;; (setq py-python-command-args '("--pylab" "--colors" "Linux"))
;; (setq org-babel-python-mode 'python-mode)
;; (setq py-python-command "ipython")

;; ;To enable code completion:
;; (require 'pycomplete)
;; (setq py-load-pymacs-p t)
;; (add-to-list 'ac-sources 'ac-source-pycomplete)

;; ;To use auto-complete, just prepend the following lines:
;; (require 'auto-complete-config)
;; (ac-config-default)

;; (setq-default indent-tabs-mode nil)    ; use only spaces and no tabs
;; (setq default-tab-width 4)

;; (require 'pymacs)
;; (pymacs-load "ropemacs" "rope-")
;; (setq ropemacs-enable-autoimport t)

(load-file (concat starter-kit-dir "/emacs-for-python/epy-init.el"))
#+end_src

** Code checking option 1: On-the-fly w/ Flymake
http://www.saltycrane.com/blog/2010/05/my-emacs-python-environment/

#+begin_src emacs-lisp
(add-hook 'find-file-hook 'flymake-find-file-hook)
(when (load "flymake" t)
  (defun flymake-pyflakes-init ()
    (let* ((temp-file (flymake-init-create-temp-buffer-copy
               'flymake-create-temp-inplace))
       (local-file (file-relative-name
            temp-file
            (file-name-directory buffer-file-name))))
      (list "pycheckers"  (list local-file))))
   (add-to-list 'flymake-allowed-file-name-masks
             '("\\.py\\'" flymake-pyflakes-init)))
;(require 'flymake-cursor)
(global-set-key [f10] 'flymake-goto-prev-error)
(global-set-key [f11] 'flymake-goto-next-error)
#+end_src

You need this shell script.
#+begin_src sh :tangle ~/bin/pycheckers
#!/bin/bash
pyflakes "$1"
pep8 --ignore=E221,E701,E202 --repeat "$1"
true
#+end_src
* jmax lisp
** line-spacing
#+BEGIN_SRC emacs-lisp
;; http://sdpconfig.wordpress.com/2011/12/21/unwrapping-paragraphs-in-emacs/
(defun unfill-paragraph ()
  "Unfill paragraph at or after point."
  (interactive "*")
  (let ((fill-column most-positive-fixnum))
    (fill-paragraph nil (region-active-p))))

(defun double-space ()
  "make buffer look approximately double-spaced"
  (interactive)
  (setq line-spacing 10))

(defun single-space ()
  "make buffer single-spaced"
  (interactive)
  (setq line-spacing nil))
#+END_SRC

** get paths and insert functions
#+BEGIN_SRC emacs-lisp
;http://www.gnu.org/software/emacs/manual/html_node/elisp/File-Name-Expansion.html#File-Name-Expansion

(defun get-path()
  "opens dired so you can navigate to a file to insert a path to it in the current buffer"
  (interactive)
  ; store current buffer so we can change back to it
  (setq current_buffer (current-buffer))
  (setq buffer_name (buffer-file-name))
  ; now call dired to navigate to the path you want
  (dired ())
)

(defun insert-relative-path()
  "inserts the relative path between the original buffer and current file selected in dired"
  (interactive)
  (setq selected_file (dired-get-filename))
  (switch-to-buffer current_buffer) ; back to the original buffer
  (insert  (file-relative-name selected_file));inserts relative path
)

(defun insert-absolute-path()
  "Inserts the absolute path to the file selected in dired"
  (interactive)
  (setq selected_file (dired-get-filename)) ; this is the file the cursor is on
  (switch-to-buffer current_buffer) ; back to the original buffer
  (insert  (expand-file-name selected_file));inserts absolute path
)

(defun insert-buffer-filename()
  "Inserts filename associated with current buffer"
  (interactive)
  (insert (buffer-file-name))
)

(global-set-key "\C-cg" 'get-path )
(global-set-key "\C-cp" 'insert-relative-path)
(global-set-key "\C-cf" 'insert-buffer-filename)
#+END_SRC

** help search functions
#+BEGIN_SRC emacs-lisp
;; http://davidavraamides.net/blog/2008/07/22/mode-aware-google-help-in-emacs/
(defun search-site-url (keyword &optional site inurl lucky)
  "Do a Google search for KEYWORD. Restrict to SITE and INURL, if specified.
Jump to best match (I Feel Lucky) if LUCKY set.
"
  (concat "http://www.google.com/"
          (format "search?q=%s" (url-hexify-string keyword))
          (if site (format "+site:%s" (url-hexify-string site)))
          (if inurl (format "+inurl:%s" (url-hexify-string inurl)))
          (if lucky "&btnI")))

(defun context-help ()
  "Open a browser window showing documentation for the word under the point.
Uses `major-mode' to optionally refine the search to a specific web site,
or a specific pattern in the URL. Defaults to a simple keyword search.
Uses `search-site-url' to do the actual search.
"
  (interactive)
  (require 'url)
  (browse-url
   (apply 'search-site-url
          (thing-at-point 'symbol)
          (cond
            ((equal major-mode 'css-mode)
             '("www.w3schools.com" "/css/" t))
            ((equal major-mode 'emacs-lisp-mode)
             '("www.gnu.org" "/emacs/"))
            ((or (equal major-mode 'html-mode)
                 (equal major-mode 'html-helper-mode))
             '("www.htmlquick.com" "/reference/" t))
            ((equal major-mode 'javascript-mode)
             '("www.w3schools.com" nil t))
            ((equal major-mode 'python-mode)
             '("docs.python.org" "/ref/" t))
	    ((equal major-mode 'vasp-mode)
	     '("http://cms.mpi.univie.ac.at" "/vasp/vasp/" t))
            (t nil)))))
#+END_SRC

** system interactions
#+BEGIN_SRC emacs-lisp
;; I think these would eventually get moved to a major mode
(defun run-cat ()
  "example function to run a shell command on  a a filename"
  (interactive)
  (shell-command (concat "cat" " " (buffer-file-name))))

(defun ncsum ()
  "runs ncsum on the current file in dired"
  "the filename should be a netcdf file, although no checks are performed."
  (interactive)
  (dired-do-shell-command "ncsum" nil (list (dired-get-filename))))

(defun ag ()
  "runs ag on the current file in dired"
  "the filename should be a file ag can read, although no checks are performed."
  (interactive)
  (dired-do-shell-command "ag" nil (list (dired-get-filename))))
#+END_SRC


\bibliography{../export}
* TODO send email through gmail
Adapted from http://wideaperture.net/blog/?p=3343

#+begin_src emacs-lisp
;;Configure Outbound Mail
;;Tell Emacs to use GNUTLS instead of STARTTLS
;;to authenticate when sending mail.
(setq starttls-use-gnutls t)

;;Tell Emacs about your mail server and credentials
(setq send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials
      '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials
      (expand-file-name "~/.authinfo")
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)
(require 'smtpmail)
#+end_src


* TODO setup gnus for reading and sending mail
Note: this is not working completely yet.

you need to create ~/.imap-authinfo see http://emacswiki.org/emacs/GnusAuthinfo

It has a format like this:
#+begin_example
machine imap.gmail.com login john_doe@gmail.com password notapassword port 993
#+end_example

#+begin_src emacs-lisp
;; Customize the next three lines with your ISP information.
(load "starttls")
(load-library "smtpmail")

;; Configure incoming mail (IMAP)
(setq gnus-select-method '(nnimap "gmail"
(nnimap-address "imap.gmail.com")
(nnimap-server-port 993)

; you need to create ~/.imap-authinfo see http://emacswiki.org/emacs/GnusAuthinfo
(nnimap-authinfo-file "~/.imap-authinfo")
(nnimap-stream ssl)))

;; Configure outbound mail (SMTP)
(setq smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-default-smtp-server "smtp.gmail.com"
      send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-smtp-service 587
      smtpmail-auth-credentials '(("smtp.gmail.com" 587 user-mail-address nil))
      smtpmail-debug-info t
      smtpmail-debug-verb t
      )
(setq smtpmail-local-domain nil)
(setq gnus-permanently-visible-groups "gmail")
(executable-find starttls-program)
#+end_src

* ebib setup
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path (concat starter-kit-dir "./ebib"))
(autoload 'ebib "ebib" "Ebib, a BibTeX database manager." t)
#+END_SRC

#+RESULTS:
| autoload | ebib | Ebib, a BibTeX database manager. | t | nil |
